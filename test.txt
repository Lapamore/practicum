Ты абсолютно прав. Текущая реализация change_dialog_group просто меняет метку в кеше, но не перенаправляет диалог нужным людям.

Если я (агент) взял диалог, понял, что это не моя тема, и выбираю "IT Поддержка", то должно произойти следующее:

Система находит ID сотрудников IT-поддержки.
Диалог снимается с меня (статус AGENT_HANDLED -> AWAITING_AGENT).
Диалог добавляется в очередь, видимую только IT-шникам.
Давай реализуем эту логику на бэкенде.

1. Обновляем AgentServiceProvider.py
Нам нужно прокинуть RoutingRepository в AgentService, чтобы сервис мог узнавать ID сотрудников по названию группы.

Файл: src/components/agent_service/di/AgentServiceProvider.py

code
Python

download

content_copy

expand_less
from dishka import Provider, provide, Scope
# ... остальные импорты ...
from ...routing.infrastructure.repositories.core import IRoutingRepository
from ...routing.infrastructure.repositories.impl import RoutingRepository

class AgentServiceProvider(Provider):
    
    # ... существующие провайдеры ...

    @provide(scope=Scope.REQUEST)
    def get_routing_repo(self, sql_client: IBaseSqlRepository) -> IRoutingRepository:
        return RoutingRepository(sql_client=sql_client)

    @provide(scope=Scope.REQUEST)
    def get_agent_service(
        self,
        dialog_repo: IDialogRepository,
        cache_repo: IDialogCacheRepository,
        queue_repo: IDialogQueueRepository,
        msg_repo: IMessageRepository,
        stats_repo: IStatisticsRepository,
        routing_repo: IRoutingRepository, # <--- ДОБАВИЛИ
    ) -> IAgentService:
        return AgentService(
            dialog_repo=dialog_repo,
            cache_repo=cache_repo,
            queue_repo=queue_repo,
            msg_repo=msg_repo,
            stats_repo=stats_repo,
            routing_repo=routing_repo,    # <--- ПЕРЕДАЛИ
        )
2. Обновляем DialogQueueRepository.py
Нам нужен метод update_queue_targeting, который найдет диалог в Redis (если он там есть) и обновит список разрешенных ID.

Файл: src/components/agent_service/infractructure/repositories/impl/DialogQueueRepository.py

code
Python

download

content_copy

expand_less
# ... (внутри класса DialogQueueRepository)

    async def update_queue_targeting(self, dialog_id: str, new_allowed_ids: List[str], new_display_group: str) -> bool:
        """
        Обновляет targeting (allowed_ids) для диалога, который УЖЕ лежит в очереди.
        """
        items = await self._cache.lrange(self.QUEUE_KEY, 0, -1)
        found_index = -1
        target_item = None

        # 1. Ищем диалог в списке
        for idx, item_str in enumerate(items):
            try:
                val = item_str.decode() if isinstance(item_str, bytes) else item_str
                item = json.loads(val)
                if item.get("dialog_id") == dialog_id:
                    found_index = idx
                    target_item = item
                    break
            except:
                continue
        
        if found_index != -1 and target_item:
            # 2. Обновляем данные
            target_item["allowed_ids"] = [str(uid) for uid in new_allowed_ids]
            target_item["display_group"] = new_display_group
            
            # 3. Перезаписываем элемент в Redis по индексу
            # ВНИМАНИЕ: LSET работает по индексу, это атомарно для элемента.
            new_payload = json.dumps(target_item)
            await self._cache._r.lset(self.QUEUE_KEY, found_index, new_payload)
            
            logger.info(f"Updated queue targeting for {dialog_id} -> {new_display_group}")
            return True
            
        return False
(Примечание: Не забудь добавить этот метод в интерфейс IDialogQueueRepository)

3. Обновляем AgentService.py
Здесь самая главная бизнес-логика. Метод change_dialog_group теперь делает "трансфер".

Файл: src/components/agent_service/infractructure/services/impl/AgentService.py

code
Python

download

content_copy

expand_less
# Импорты RoutingRepo добавь в начале файла
from ...routing.infrastructure.repositories.core import IRoutingRepository

class AgentService(IAgentService):
    def __init__(
        self,
        dialog_repo: IDialogRepository,
        cache_repo: IDialogCacheRepository,
        queue_repo: IDialogQueueRepository,
        msg_repo:  IMessageRepository,
        stats_repo:  IStatisticsRepository,
        routing_repo: IRoutingRepository, # <--- Принимаем
    ):
        self._dialog = dialog_repo
        self._cache = cache_repo
        self._queue = queue_repo
        self._msg = msg_repo
        self._stats = stats_repo
        self._routing = routing_repo # <--- Сохраняем

    # ... другие методы ...

    async def change_dialog_group(
        self, 
        dialog_id: str, 
        new_group_id: str # Это group_code, например "payroll" или "s0004"
    ) -> Dict[str, str]: 
        
        # 1. Получаем список ID сотрудников для новой группы
        target_ids = await self._routing.get_working_group_ids(new_group_id)
        
        # Если группа не найдена в базе (например "general"), пробуем fallback или логику по умолчанию
        if not target_ids:
            # Можно сделать хардкод fallback'а или кинуть ошибку
            # Для примера: если "general", ищем по коду "general_code" или берем всех
            logger.warning(f"No agents found for group {new_group_id}, checking fallback...")
            # Пытаемся найти по самому коду, если это алиас
            # Если нет - кидаем ошибку, что перевести некому
            if new_group_id == "general":
                 # Пример: у general может быть код m0000
                 target_ids = await self._routing.get_working_group_ids("m0000") 
            
            if not target_ids:
                 # В крайнем случае - пустой список (виден никому или всем, зависит от логики репо)
                 # Лучше кинуть ошибку, чтобы фронт сказал "Некому передать"
                 return {"status": "error", "message": "No agents available for this group"}

        target_ids_str = [str(x) for x in target_ids]

        # 2. Обновляем метку группы в кеше (для красоты)
        await self._cache.set_work_group(dialog_id, new_group_id)

        # 3. Проверяем, где сейчас диалог: в очереди или у агента?
        is_in_queue = await self._queue.update_queue_targeting(
            dialog_id, 
            target_ids_str, 
            new_display_group=new_group_id
        )

        if is_in_queue:
            # Сценарий A: Диалог был в очереди. Мы просто обновили permissions внутри Redis.
            return {"status": "ok", "message": "Queue updated"}
        
        else:
            # Сценарий B: Диалог был у агента (claimed). Нужно ВЕРНУТЬ его в очередь.
            
            # 1. Снимаем текущего агента
            await self._cache.release_dialog(dialog_id)
            
            # 2. Меняем статус на AWAITING_AGENT
            await self._cache.set_state(dialog_id, DialogState.AWAITING_AGENT.value)
            
            # 3. Добавляем системное сообщение (опционально)
            system_msg = f"Диалог переведен на группу '{new_group_id}'."
            # ... логика добавления сообщения в историю ...

            # 4. Добавляем в конец очереди с новыми ID
            await self._queue.add_to_queue_targeted(
                dialog_id=dialog_id,
                user_id=await self._cache.get_user_id(dialog_id), # Достаем user_id из кеша
                allowed_ids=target_ids_str
            )
            
            # 5. Логируем смену статуса в SQL
            await self._dialog.set_status(
                dialog_id, 
                "system", # или user_id
                DialogState.AWAITING_AGENT.value, 
                "TRANSFER"
            )

            return {"status": "ok", "message": "Transferred to queue"}
4. Доработка БД (Важно!)
Ты должен убедиться, что в таблице missa_bidr.ai_copilot_support_routing есть записи для тех group_code, которые отправляет фронтенд.

Фронт отправляет (из SupportGroupModal.tsx):

general
payroll
it_support
reporting
Значит, в таблице должны быть такие строки (пример):

group_code	agent_ids	description
general	[22861759, 11111111]	Общие вопросы
payroll	[22861759]	Зарплата
it_support	[55555555]	IT
s0004	[22861759]	Куб гарантий (это от AI)
Если кодов general и т.д. нет в таблице, get_working_group_ids вернет None, и трансфер не сработает (или сработает fallback).

Резюме изменений
Пользователь/Агент выбирает группу "IT Support".
Frontend шлет POST change_dialog_group { group_id: "it_support" }.
Backend идет в базу, ищет group_code="it_support", получает список [555, 777].
Backend выкидывает диалог из "Моих" текущего агента.
Backend кладет диалог в очередь с пометкой allowed_ids=[555, 777].
Текущий агент (если он не 555/777) теряет доступ.
Агент 555 видит диалог в "Ожидающих".
Все логично и безопасно.
