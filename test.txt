Нет, удалять пока нельзя, но мы сейчас сделаем так, чтобы можно было удалить.

В чем подвох?
У тебя есть два пути, как диалог попадает в очередь:

AI (автоматически): Использует новый метод join_targeted_support -> add_to_queue_targeted.
Ручной выбор (через модалку): Использует старый метод join_support_queue -> add_to_queue.
Если ты сейчас удалишь add_to_queue, сломается ручной выбор (когда пользователь сам тыкает "ФОТ" или "IT").

Как сделать правильно (Унификация)
Давай обновим старый метод join_support_queue в AgentService, чтобы он тоже искал ID сотрудников и использовал новую логику. Тогда старый метод в репозитории станет не нужен.

Шаг 1. Обновляем AgentService.py
Мы переписываем join_support_queue (ручной выбор), чтобы он работал через RoutingRepository и новый add_to_queue_targeted.

Файл: src/components/agent_service/infractructure/services/impl/AgentService.py

code
Python

download

content_copy

expand_less
# ... внутри AgentService ...

    async def join_support_queue(
        self, 
        dialog_id: str, 
        user_id: str, 
        group_id: str # Приходит от фронта: 'payroll', 'it_support' и т.д.
    ) -> Dict[str, str]:
        
        # 1. Пытаемся найти ID сотрудников для выбранной группы
        # group_id здесь выступает как group_code
        target_ids = await self._routing.get_working_group_ids(group_id)
        
        # Если для этой группы в базе нет сотрудников (или это 'general'),
        # можно либо кинуть ошибку, либо отправить в "общую кучу" (пустой список ID)
        if not target_ids:
            # Fallback: если ID не найдены, список пустой (зависит от твоей логики фильтрации:
            # пустой список = видят все ИЛИ видят только админы).
            # Допустим, если не нашли, пробуем найти для 'general'
            target_ids = await self._routing.get_working_group_ids('general') or []

        # Преобразуем в строки для надежности (если в базе int)
        target_ids_str = [str(x) for x in target_ids]

        # 2. Сохраняем метаданные
        await self._cache.set_work_group(dialog_id, group_id)
        
        # 3. Логируем статус
        await self._dialog.set_status(
            dialog_id, user_id, 
            DialogState.AWAITING_AGENT.value, 
            "USER_MANUAL"
        )
        
        # 4. Кеш статуса
        await self._cache.set_state(dialog_id, DialogState.AWAITING_AGENT.value)
        
        # 5. ВАЖНО: Используем НОВЫЙ метод репозитория
        # Даже для ручного выбора мы теперь используем таргетинг по ID
        await self._queue.add_to_queue_targeted(
            dialog_id=dialog_id, 
            user_id=user_id, 
            allowed_agent_ids=target_ids_str,
            display_group_name=group_id # Используем ID группы как название для отображения
        )
        
        return {"status": "ok", "message": "Queued manually"}
Шаг 2. Чистим DialogQueueRepository.py
Теперь, когда оба метода сервиса (join_targeted_support и join_support_queue) используют add_to_queue_targeted, старый add_to_queue можно удалить (или переименовать в add_to_queue_targeted, чтобы было короче).

Файл: src/components/agent_service/infractructure/repositories/impl/DialogQueueRepository.py

code
Python

download

content_copy

expand_less
# ...

    # ОСТАВЛЯЕМ ТОЛЬКО ЭТОТ МЕТОД (можно переименовать его обратно в add_to_queue, если поправишь интерфейс)
    async def add_to_queue_targeted(
        self, 
        dialog_id: str, 
        user_id: str, 
        allowed_agent_ids: List[Union[str, int]], 
        display_group_name: str = "General"
    ) -> None:
        
        allowed_ids_str = [str(aid) for aid in allowed_agent_ids]

        payload = json.dumps({
            "dialog_id": dialog_id,
            "user_id": user_id,
            "allowed_ids": allowed_ids_str,
            "display_group": display_group_name,
            "timestamp": "..."
        })
        
        await self._cache.rpush(self.QUEUE_KEY, [payload])
        logger.info(f"Dialog {dialog_id} added to queue. Target Agents: {allowed_ids_str}")

    # СТАРЫЙ add_to_queue УДАЛЯЕМ
Итог
Теперь у тебя единая логика:

И AI, и Пользователь выбирают группу.
Сервис всегда идет в базу (RoutingRepository) и превращает группу в список ID сотрудников.
В очередь всегда попадает диалог с полем allowed_ids.
Агент всегда видит только то, что ему разрешено.
Это самая чистая архитектура.
