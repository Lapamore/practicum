Понял. Значит, логика следующая:

Сценарий "Комментарий": Если AI понял, что это шаблонный вопрос (Бизнес-план, Прогноз), он отдает текст и не ставит в очередь. Диалог закрывается/остается на AI.
Сценарий "Роутинг": Если AI нашел group_ids (список конкретных ID сотрудников), он ставит диалог в очередь, привязывая его к этому списку.
Фильтрация: Когда сотрудник заходит в интерфейс ("Ожидающие диалоги"), он должен видеть только те диалоги, в списке group_ids которых есть его ID.
Давай реализуем это. Нам нужно протащить этот список ID от CallSupportTool через сервис в репозиторий, а потом использовать его для фильтрации при выдаче.

1. Обновляем CallSupportTool.py
Здесь мы запускаем пайплайн. Если вернулся комментарий — отдаем его. Если вернулись ID — зовем сервис с передачей этих ID.

Файл: src/components/tools/impl/CallSupportTool.py

code
Python

download

content_copy

expand_less
import uuid
import logging
from typing import List

from langchain_core.tools import BaseTool
from langchain_core.messages import HumanMessage, AIMessage, SystemMessage

from ...models import DialogState
from ...agent_service.infractructure.services.core import IAgentService
from ...routing.infrastructure.ai_pipeline.base import TreePipeline, TreeRequestContext
from ...routing.infrastructure.repositories.core import IRoutingRepository
from mbi.copilot.src.infrastructure.keydb.core import ICache

logger = logging.getLogger(__name__)

__all__ = ["CallSupportTool"]


class CallSupportTool(BaseTool):
    name: str = "/support"
    description: str = "Функция, позволяющая вызвать сотрудника сопровождения."

    cache: ICache
    agent_service: IAgentService
    tree_pipeline: TreePipeline
    routing_repo: IRoutingRepository

    class Config:
        arbitrary_types_allowed = True

    def _run(self):
        raise NotImplementedError("Sync execution not supported.")

    async def _arun(self, dialog_id: str, user_id: str):
        if not dialog_id or not user_id:
            return "Ошибка: Не удалось определить ID диалога."

        # 1. Проверяем, не в очереди ли уже
        current_state = await self.cache.get(f"dialog:{dialog_id}:state")
        if current_state and current_state not in [DialogState.AI_HANDLED.value, None]:
            return "Процесс вызова сотрудника уже инициирован."

        # 2. Получаем историю и готовим контекст
        raw_history = await self.agent_service.get_dialog_history(user_id=user_id, session_id=dialog_id)
        langchain_history = []
        for msg in raw_history:
            role = msg.get("role", "")
            content = msg.get("content", "")
            if role == "user":
                langchain_history.append(HumanMessage(content=content))
            elif role == "system":
                langchain_history.append(SystemMessage(content=content))
            else:
                langchain_history.append(AIMessage(content=content))

        tree_context = TreeRequestContext(history=langchain_history)

        # 3. Запускаем Pipeline классификации
        try:
            result_context = await self.tree_pipeline.execute(tree_context)
        except Exception as e:
            logger.error(f"TreePipeline error: {e}")
            result_context = tree_context

        # --- СЦЕНАРИЙ 1: Есть комментарий (Шаблонный ответ) ---
        # Мы НЕ ставим в очередь, просто отдаем ответ пользователю.
        if result_context.comment:
            return (
                result_context.comment,  # Текст ответа
                DialogState.AI_HANDLED.value # Статус остается на AI
            )

        # --- СЦЕНАРИЙ 2: Есть список ID сотрудников (Роутинг) ---
        group_ids = result_context.group_ids
        group_code = result_context.group_code
        
        # Если пайплайн вернул код, но не ID (например, на шаге SelectTheme), резолвим через репозиторий
        if not group_ids and group_code:
            try:
                group_ids = await self.routing_repo.get_working_group_ids(group_code)
            except Exception as e:
                logger.error(f"Failed to resolve group_code {group_code}: {e}")

        if group_ids:
            try:
                # Преобразуем к списку строк или int, как удобнее. 
                # Допустим, ids приходят int, но храним как есть.
                target_ids = list(group_ids)
                
                # Вызываем новый метод с передачей списка ID
                await self.agent_service.join_support_queue_with_ids(
                    dialog_id=dialog_id,
                    user_id=user_id,
                    target_agent_ids=target_ids,
                    group_code=group_code or "manual_routing"
                )
                
                product_name = result_context.product_category or "специализированную группу"
                return (
                    f"Я перевел ваш диалог на группу «{product_name}». Ожидайте подключения оператора.",
                    DialogState.AWAITING_AGENT.value
                )
            except Exception as e:
                logger.error(f"Error auto-joining queue with IDs: {e}")
                # Fallback если не получилось

        # --- СЦЕНАРИЙ 3: Fallback (Ручной выбор) ---
        # Если не определили ни комментарий, ни группу -> отправляем в ручной выбор
        try:
            # Тут ставим статус CHOOSING_GROUP, чтобы фронт показал меню
            await self.cache.set(f"dialog:{dialog_id}:state", DialogState.CHOOSING_GROUP.value)
            
            # Логируем в SQL как "AI перевел на выбор"
            await self.agent_service._dialog.set_status(
                dialog_id, user_id, 
                DialogState.CHOOSING_GROUP.value, 
                "AI"
            )
        except Exception as e:
            logger.error(f"Error setting manual selection state: {e}")
            return "Произошла ошибка."

        return (
            "Я не смог точно определить категорию вопроса. Пожалуйста, выберите тему вручную.",
            DialogState.CHOOSING_GROUP.value
        )
2. Обновляем IAgentService и AgentService
Нужно добавить метод для постановки в очередь с конкретными ID и обновить метод получения диалогов, чтобы он фильтровал выдачу.

Файл: src/components/agent_service/infractructure/services/core/IAgentService.py

code
Python

download

content_copy

expand_less
# ... внутри класса IAgentService ...

    @abstractmethod
    async def join_support_queue_with_ids(
        self, 
        dialog_id: str, 
        user_id: str, 
        target_agent_ids: List[int],
        group_code: str
    ) -> None:
        """Поставить в очередь, видимую только конкретным агентам"""
        raise NotImplementedError

    @abstractmethod
    async def get_awaiting_dialogs(self, requesting_agent_id: str) -> List[DialogModel]:
        """Получить диалоги, доступные конкретному агенту"""
        raise NotImplementedError
Файл: src/components/agent_service/infractructure/services/impl/AgentService.py

code
Python

download

content_copy

expand_less
# ... внутри класса AgentService ...

    async def join_support_queue_with_ids(
        self, 
        dialog_id: str, 
        user_id: str, 
        target_agent_ids: List[int],
        group_code: str
    ) -> None:
        # 1. Сохраняем метаданные (код группы) в кеш, пригодится для статистики
        await self._cache.set_work_group(dialog_id, group_code)
        
        # 2. Логируем статус в SQL
        await self._dialog.set_status(
            dialog_id, user_id, 
            DialogState.AWAITING_AGENT.value, 
            "AI_ROUTER"
        )
        
        # 3. Обновляем статус в Redis
        await self._cache.set_state(dialog_id, DialogState.AWAITING_AGENT.value)
        
        # 4. Добавляем в очередь с указанием разрешенных ID
        await self._queue.add_to_queue_targeted(dialog_id, user_id, target_agent_ids)


    async def get_awaiting_dialogs(self, requesting_agent_id: str) -> List[DialogModel]:
        # Передаем ID запрашивающего агента в репозиторий для фильтрации
        return await self._queue.get_awaiting_dialogs(requesting_agent_id)
3. Обновляем Репозиторий Очереди (DialogQueueRepository)
Здесь происходит магия фильтрации. Мы храним список ID в payload и проверяем его при чтении.

Файл: src/components/agent_service/infractructure/repositories/core/IDialogQueueRepository.py

code
Python

download

content_copy

expand_less
@abstractmethod
    async def add_to_queue_targeted(self, dialog_id: str, user_id: str, allowed_ids: List[int]) -> None:
        raise NotImplementedError

    @abstractmethod
    async def get_awaiting_dialogs(self, requesting_agent_id: Optional[str] = None) -> List[DialogModel]:
        # Обновили сигнатуру: добавили requesting_agent_id
        raise NotImplementedError
Файл: src/components/agent_service/infractructure/repositories/impl/DialogQueueRepository.py

code
Python

download

content_copy

expand_less
import json
import logging
from typing import List, Optional

from ..core import IDialogQueueRepository
from ....models import DialogModel
from mbi.copilot.src.infrastructure.keydb.core import ICache

__all__ = ["DialogQueueRepository"]

logger = logging.getLogger(__name__)


class DialogQueueRepository(IDialogQueueRepository):

    QUEUE_KEY = "dialogs:awaiting_agent_queue"

    def __init__(self, cache: ICache):
        self._cache = cache

    async def add_to_queue_targeted(self, dialog_id: str, user_id: str, allowed_ids: List[int]) -> None:
        payload = json.dumps({
            "dialog_id": dialog_id,
            "user_id": user_id,
            "allowed_ids": allowed_ids,  # Сохраняем список ID
            "timestamp": "..." # Можно добавить время добавления
        })
        await self._cache.rpush(self.QUEUE_KEY, [payload])
        logger.info(f"Dialog {dialog_id} added to queue for agents: {allowed_ids}")

    # Старый метод (для совместимости или fallback)
    async def add_to_queue(self, dialog_id: str, user_id: str, group_id: str) -> None:
        # Если используется старый метод, считаем что group_id это просто маркер,
        # но лучше перевести всё на targeted. Или сохранять group_id как allowed_ids=[group_id]
        payload = json.dumps({
            "dialog_id": dialog_id,
            "user_id": user_id,
            "legacy_group": group_id 
        })
        await self._cache.rpush(self.QUEUE_KEY, [payload])

    async def get_awaiting_dialogs(self, requesting_agent_id: Optional[str] = None) -> List[DialogModel]:
        payloads = await self._cache.lrange(self.QUEUE_KEY, 0, -1)
        dialogs = []
        
        # Приводим requesting_agent_id к int для сравнения, если он числовой
        req_id_int = None
        if requesting_agent_id and requesting_agent_id.isdigit():
            req_id_int = int(requesting_agent_id)

        for payload_str in payloads:
            try:
                if isinstance(payload_str, bytes):
                    payload_str = payload_str.decode()
                item = json.loads(payload_str)
                
                # === ЛОГИКА ФИЛЬТРАЦИИ ===
                allowed_ids = item.get("allowed_ids") # Список [22861759, ...]
                
                is_visible = False
                
                if allowed_ids:
                    # Это диалог с таргетингом
                    if requesting_agent_id:
                        # Проверяем, есть ли наш агент в списке (как int или str)
                        if (req_id_int in allowed_ids) or (requesting_agent_id in allowed_ids) or (str(req_id_int) in [str(x) for x in allowed_ids]):
                            is_visible = True
                    else:
                        # Если ID не передан (админский просмотр?), показываем всё или ничего (зависит от бизнес-логики)
                        is_visible = True 
                else:
                    # Это старый диалог или диалог "для всех" (fallback)
                    # Если нужно показывать такие диалоги всем - True
                    # Если только для general группы - проверка legacy_group
                    is_visible = True

                if is_visible:
                    dialogs.append(DialogModel(
                        id=item["dialog_id"],
                        userId=item["user_id"],
                        # workGroupId больше не является единственным идентификатором,
                        # но можно отдать метку для фронта
                        workGroupId="targeted" if allowed_ids else item.get("legacy_group", "general")
                    ))
                    
            except (json.JSONDecodeError, TypeError, KeyError) as e:
                logger.error(f"Queue parse error: {e}")

        return dialogs

    # Остальные методы (remove, update) нужно обновить, чтобы они искали по dialog_id внутри JSON
    # так как структура JSON изменилась
4. Обновляем Хендлер (GetAwaitingDialogsHandler)
Теперь хендлер должен вытаскивать agent_id из параметров запроса (которые приходят от фронта) и передавать их в сервис.

Файл: src/web/routing/handlers/get/GetAwaitingDialogsHandler.py

code
Python

download

content_copy

expand_less
from typing import List, Dict
from ....models.request import AgentIdRequest # Предполагаем, что есть Request с agent_id, или используем Dict
from mbi.copilot.src.components.agent_service.models import DialogModel
from mbi.copilot.src.components.agent_service.infractructure.services.core import IAgentService

__all__ = ["GetAwaitingDialogsHandler"]


class GetAwaitingDialogsHandler:
    action_name: str = "get_awaiting_dialogs"

    def __init__(self, agent_service: IAgentService) -> None:
        self._agent_service = agent_service

    async def handle(self, params: Dict) -> Dict[str, List[Dict]]:
        # Пытаемся достать agent_id. 
        # Если фронт его не шлет, фильтрация не сработает (или вернет всё/ничего, как настроим в Repo).
        agent_id = params.get("agent_id")
        
        if not agent_id and "params" in params:
             agent_id = params["params"].get("agent_id")

        awaiting_dialogs = await self._agent_service.get_awaiting_dialogs(
            requesting_agent_id=str(agent_id) if agent_id else None
        )
        
        return {"dialogs": [d.model_dump() for d in awaiting_dialogs]}
Итог:

AI (Tool) определяет список ID ([123, 456]).
Service кладет в Redis JSON: {"allowed_ids": [123, 456], ...}.
Сотрудник 123 делает запрос get_awaiting_dialogs(agent_id=123).
Repo видит 123 в allowed_ids и отдает диалог.
Сотрудник 999 делает запрос get_awaiting_dialogs(agent_id=999).
Repo не видит 999 в списке и не отдает диалог.
Все требования соблюдены.
